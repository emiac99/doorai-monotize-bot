# shrinkme_referrals_bot.py
# Mode A + qualified referrals (counts when referred user reaches 20 total clicks)
# WARNING: Do NOT hardcode your TELEGRAM token here. Use environment variables on Render.

import os, sqlite3, threading, time, hashlib
from datetime import datetime, date, timedelta
from urllib.parse import urlencode
from flask import Flask, request, redirect, abort
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# ---------- CONFIG (use Render env vars) ----------
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")  # set on Render
ADMIN_IDS = [int(x) for x in os.getenv("ADMIN_IDS", "").split(",") if x.strip().isdigit()]
DOMAIN = os.getenv("DOMAIN", "https://yourapp.onrender.com")  # set after deploy
DB_PATH = os.getenv("DB_PATH", "shrinkme_referrals.db")
REQUIRED_CLICKS_PER_DAY = int(os.getenv("REQUIRED_CLICKS_PER_DAY", "20"))
REFERRAL_QUALIFY_CLICKS = int(os.getenv("REFERRAL_QUALIFY_CLICKS", "20"))  # counts when referee reaches this many total clicks
DAILY_REPORT_HOUR = int(os.getenv("DAILY_REPORT_HOUR", "0"))  # UTC hour
DAILY_REPORT_MIN = int(os.getenv("DAILY_REPORT_MIN", "5"))   # UTC minute
INITIAL_SHRINKME = os.getenv("SHRINKME_LINK", "")  # optional prefill

# ---------- DB helpers ----------
def init_db():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    # users
    c.execute("""
    CREATE TABLE IF NOT EXISTS users (
        tg_id INTEGER PRIMARY KEY,
        username TEXT,
        created_at TEXT,
        qualified_referrals INTEGER DEFAULT 0
    )""")
    # settings
    c.execute("""CREATE TABLE IF NOT EXISTS settings (k TEXT PRIMARY KEY, v TEXT)""")
    # clicks: every redirect open creates a row (history)
    c.execute("""
    CREATE TABLE IF NOT EXISTS clicks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        tg_id INTEGER,
        click_date TEXT,
        ip_hash TEXT,
        ua_hash TEXT,
        created_at TEXT
    )""")
    # referrals: mapping referrer -> referee
    c.execute("""
    CREATE TABLE IF NOT EXISTS referrals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        referrer INTEGER,
        referee INTEGER UNIQUE,
        qualified INTEGER DEFAULT 0,
        created_at TEXT
    )""")
    conn.commit()
    if INITIAL_SHRINKME:
        c.execute("INSERT OR REPLACE INTO settings(k,v) VALUES(?,?)", ("shrinkme", INITIAL_SHRINKME))
        conn.commit()
    conn.close()

def db_conn():
    return sqlite3.connect(DB_PATH)

# ---------- utilities ----------
def today_str():
    return date.today().isoformat()

def fingerprint(ip, ua):
    s = f"{ip}|{ua}"
    return hashlib.sha256(s.encode()).hexdigest()

def add_user_if_missing(tg_id, username=None):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT 1 FROM users WHERE tg_id=?", (tg_id,))
    if not c.fetchone():
        c.execute("INSERT INTO users(tg_id, username, created_at) VALUES(?,?,?)", (tg_id, username or "", datetime.utcnow().isoformat()))
        conn.commit()
    conn.close()

def get_shrinkme():
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT v FROM settings WHERE k='shrinkme'")
    r = c.fetchone(); conn.close()
    return r[0] if r else None

def set_shrinkme(url):
    conn = db_conn(); c = conn.cursor()
    c.execute("INSERT OR REPLACE INTO settings(k,v) VALUES(?,?)", ("shrinkme", url))
    conn.commit(); conn.close()

def count_user_total(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM clicks WHERE tg_id=?", (tg_id,))
    r = c.fetchone()[0]; conn.close()
    return r

def count_user_today(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT COUNT(*) FROM clicks WHERE tg_id=? AND click_date=?", (tg_id, today_str()))
    r = c.fetchone()[0]; conn.close()
    return r

def record_click(tg_id, ip_hash, ua_hash):
    conn = db_conn(); c = conn.cursor()
    # prevent duplicate fingerprint for same user on same day
    c.execute("SELECT 1 FROM clicks WHERE tg_id=? AND click_date=? AND ip_hash=?", (tg_id, today_str(), ip_hash))
    if c.fetchone():
        conn.close(); return False
    c.execute("INSERT INTO clicks(tg_id, click_date, ip_hash, ua_hash, created_at) VALUES(?,?,?,?,?)",
              (tg_id, today_str(), ip_hash, ua_hash, datetime.utcnow().isoformat()))
    conn.commit()
    # check referral qualification logic
    # if this user was referred and not yet qualified, and now total clicks >= REFERRAL_QUALIFY_CLICKS -> mark qualified
    c.execute("SELECT referrer, qualified FROM referrals WHERE referee=?", (tg_id,))
    row = c.fetchone()
    if row:
        referrer, qualified = row
        if not qualified:
            # compute total clicks for referee
            c.execute("SELECT COUNT(*) FROM clicks WHERE tg_id=?", (tg_id,))
            total = c.fetchone()[0]
            if total >= REFERRAL_QUALIFY_CLICKS:
                # mark referral qualified and increment referrer's qualified_referrals
                c.execute("UPDATE referrals SET qualified=1 WHERE referee=?", (tg_id,))
                c.execute("UPDATE users SET qualified_referrals = qualified_referrals + 1 WHERE tg_id=?", (referrer,))
    conn.commit(); conn.close()
    return True

def add_referral_if_present(new_user_id, start_payload):
    """
    start_payload example: 'ref_123456'
    If valid and not already referred, create a referrals row with qualified=0.
    """
    if not start_payload or not start_payload.startswith("ref_"):
        return
    try:
        referrer = int(start_payload.split("_",1)[1])
    except:
        return
    # do not allow self-referral
    if referrer == new_user_id:
        return
    conn = db_conn(); c = conn.cursor()
    # check referee not already present (unique constraint)
    c.execute("SELECT 1 FROM referrals WHERE referee=?", (new_user_id,))
    if c.fetchone():
        conn.close(); return
    # ensure referrer exists as user record
    c.execute("SELECT 1 FROM users WHERE tg_id=?", (referrer,))
    if not c.fetchone():
        # unknown referrer: still insert referral but referrer may be added later
        pass
    c.execute("INSERT INTO referrals(referrer, referee, qualified, created_at) VALUES(?,?,0,?)", (referrer, new_user_id, datetime.utcnow().isoformat()))
    conn.commit(); conn.close()

def get_my_referrals(tg_id):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT referee, qualified, created_at FROM referrals WHERE referrer=? ORDER BY created_at DESC", (tg_id,))
    rows = c.fetchall(); conn.close()
    return rows

def get_referral_leaderboard(limit=20):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT tg_id, qualified_referrals FROM users ORDER BY qualified_referrals DESC LIMIT ?", (limit,))
    rows = c.fetchall(); conn.close()
    return rows

def get_referral_details():
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT referrer, referee, qualified, created_at FROM referrals ORDER BY created_at DESC LIMIT 500")
    rows = c.fetchall(); conn.close()
    return rows

def get_qualified_today(required=REQUIRED_CLICKS_PER_DAY):
    conn = db_conn(); c = conn.cursor()
    c.execute("SELECT tg_id, COUNT(*) as clicks FROM clicks WHERE click_date=? GROUP BY tg_id HAVING clicks>=? ORDER BY clicks DESC", (today_str(), required))
    rows = c.fetchall(); conn.close()
    return rows

def get_top_clickers(limit=20):
    conn = db_conn(); c = conn.cursor()
    week_ago = (date.today() - timedelta(days=6)).isoformat()
    c.execute("SELECT tg_id, COUNT(*) as clicks FROM clicks WHERE click_date >= ? GROUP BY tg_id ORDER BY clicks DESC LIMIT ?", (week_ago, limit))
    rows = c.fetchall(); conn.close()
    return rows

# ---------- Flask redirect endpoint ----------
app = Flask(__name__)

@app.route("/")
def home():
    return "ShrinkMe Qualified Referral Bot"

@app.route("/r")
def redirect_to_shrinkme():
    # param: u=<tg_id>
    tg_param = request.args.get("u")
    if not tg_param or not tg_param.isdigit():
        abort(400, "Missing user param")
    tg_id = int(tg_param)
    shrinkme_url = get_shrinkme()
    if not shrinkme_url:
        abort(500, "ShrinkMe link not set")
    # fingerprint
    ip = request.headers.get("X-Forwarded-For", request.remote_addr) or "0.0.0.0"
    ua = (request.headers.get("User-Agent") or "")[:500]
    ip_hash = hashlib.sha256(ip.encode()).hexdigest()
    ua_hash = hashlib.sha256(ua.encode()).hexdigest()
    # ensure user exists in users table
    add_user_if_missing(tg_id)
    # record click
    record_click(tg_id, ip_hash, ua_hash)
    return redirect(shrinkme_url, code=302)

# ---------- Telegram handlers ----------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    # detect start payload
    payload = None
    if context.args:
        payload = context.args[0]
    add_user_if_missing(user.id, user.username)
    # try to create referral if payload present
    add_referral_if_present(user.id, payload)
    await update.message.reply_text("Welcome! Use /getlink to open the ShrinkMe link. Use /getreferral to get your referral link to invite others. Use /progress to see today's clicks.")

async def getlink(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    shrinkme = get_shrinkme()
    if not shrinkme:
        await update.message.reply_text("Admin hasn't set ShrinkMe link yet.")
        return
    redirect_url = f"{DOMAIN}/r?{urlencode({'u':str(user.id)})}"
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("Open ShrinkMe link", url=redirect_url)]])
    await update.message.reply_text(f"Tap the button to open the link. Each real open counts toward your clicks.", reply_markup=kb)

async def progress(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    today = count_user_today(user.id)
    total = count_user_total(user.id)
    remaining = max(0, REQUIRED_CLICKS_PER_DAY - today)
    await update.message.reply_text(f"Today's clicks: {today}/{REQUIRED_CLICKS_PER_DAY}. Total clicks: {total}. {remaining} to go today.")

# Referral commands
async def getreferral(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    # referral deep link: t.me/<bot>?start=ref_<tg_id>
    bot_username = os.getenv("BOT_USERNAME", "")
    if bot_username:
        link = f"https://t.me/{bot_username}?start=ref_{user.id}"
    else:
        # fallback: Telegram can use t.me/<botusername>, but user should set BOT_USERNAME env var on Render
        link = f"https://t.me/{os.getenv('BOT_USERNAME','YourBotUsername')}?start=ref_{user.id}"
    await update.message.reply_text(f"Share this link to invite friends:\n{link}\nReferral counts when the referred user reaches {REFERRAL_QUALIFY_CLICKS} total clicks.")

async def myreferrals(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    rows = get_my_referrals(user.id)
    if not rows:
        await update.message.reply_text("You have no referrals yet.")
        return
    lines = []
    for r in rows:
        referee, qualified, created = r
        lines.append(f"{referee} â€” {'Qualified' if qualified else 'Pending'} â€” joined {created[:19]}")
    await update.message.reply_text("Your referrals:\n" + "\n".join(lines))

async def myreferral_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    add_user_if_missing(user.id, user.username)
    rows = get_my_referrals(user.id)
    total = len(rows)
    qualified = sum(1 for r in rows if r[1])
    pending = total - qualified
    await update.message.reply_text(f"Total invited: {total}\nQualified: {qualified}\nPending: {pending}")

# Admin commands
def is_admin(tg_id):
    return tg_id in ADMIN_IDS

async def referral_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("Only admin.")
        return
    rows = get_referral_leaderboard()
    if not rows:
        await update.message.reply_text("No referrals yet.")
        return
    lines = []
    for i, r in enumerate(rows):
        tg, q = r
        lines.append(f"{i+1}. {tg} â€” {q} qualified")
    await update.message.reply_text("Top referrers:\n" + "\n".join(lines))

async def get_referral_details_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("Only admin.")
        return
    rows = get_referral_details()
    if not rows:
        await update.message.reply_text("No referrals.")
        return
    lines = []
    for r in rows[:200]:
        referrer, referee, qualified, created = r
        lines.append(f"{referrer} -> {referee} â€” {'Q' if qualified else 'P'} â€” {created[:16]}")
    await update.message.reply_text("Referrals (latest):\n" + "\n".join(lines))

# Other admin and info commands
async def setshrinkme(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("Only admin.")
        return
    if not context.args:
        await update.message.reply_text("Usage: /setshrinkme <shrinkme_url>")
        return
    url = context.args[0].strip()
    set_shrinkme(url)
    await update.message.reply_text(f"ShrinkMe set to: {url}")

async def qualified_today_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("Only admin.")
        return
    rows = get_qualified_today()
    if not rows:
        await update.message.reply_text("No qualified users today.")
        return
    lines = [f"{i+1}. {r[0]} â€” {r[1]} clicks" for i,r in enumerate(rows)]
    await update.message.reply_text("Qualified today:\n" + "\n".join(lines))

async def top_clickers_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if not is_admin(user.id):
        await update.message.reply_text("Only admin.")
        return
    rows = get_top_clickers()
    if not rows:
        await update.message.reply_text("No click data.")
        return
    lines = [f"{i+1}. {r[0]} â€” {r[1]} clicks (last 7 days)" for i,r in enumerate(rows)]
    await update.message.reply_text("Top clickers:\n" + "\n".join(lines))

# ---------- Daily report worker ----------
def seconds_until_next_report(hour=DAILY_REPORT_HOUR, minute=DAILY_REPORT_MIN):
    from datetime import datetime, timezone
    now = datetime.utcnow()
    target = now.replace(hour=hour, minute=minute, second=10, microsecond=0)
    if target <= now:
        target = target + timedelta(days=1)
    return (target - now).total_seconds()

def daily_report_worker(application):
    import asyncio
    while True:
        wait = seconds_until_next_report()
        print("[daily_report] sleeping", wait)
        time.sleep(wait)
        try:
            rows = get_qualified_today()
            if not rows:
                text = f"ðŸŽ¯ Daily qualified users ({today_str()}): None"
            else:
                lines = []
                for i, r in enumerate(rows):
                    tg = r[0]; clicks = r[1]
                    conn = db_conn(); c = conn.cursor()
                    c.execute("SELECT username FROM users WHERE tg_id=?", (tg,))
                    rr = c.fetchone(); conn.close()
                    uname = rr[0] if rr and rr[0] else f"{tg}"
                    lines.append(f"{i+1}. @{uname} ({tg}) â€” {clicks} clicks")
                text = "ðŸŽ‰ Daily Qualified Users:\n" + "\n".join(lines)
            for admin in ADMIN_IDS:
                try:
                    asyncio.run(application.bot.send_message(chat_id=admin, text=text))
                except Exception as e:
                    print("send daily report failed", admin, e)
        except Exception as e:
            print("daily report error", e)
        # loop continues

# ---------- Run Flask + Telegram ----------
def run_flask():
    port = int(os.getenv("PORT", "5000"))
    app.run(host="0.0.0.0", port=port)

def run_telegram():
    application = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("getlink", getlink))
    application.add_handler(CommandHandler("progress", progress))
    application.add_handler(CommandHandler("getreferral", getreferral))
    application.add_handler(CommandHandler("myreferrals", myreferrals))
    application.add_handler(CommandHandler("myreferral_stats", myreferral_stats))
    application.add_handler(CommandHandler("referral_leaderboard", referral_leaderboard))
    application.add_handler(CommandHandler("get_referral_details", get_referral_details_cmd))
    application.add_handler(CommandHandler("setshrinkme", setshrinkme))
    application.add_handler(CommandHandler("qualified_today", qualified_today_cmd))
    application.add_handler(CommandHandler("top_clickers", top_clickers_cmd))
    # start daily report thread
    t = threading.Thread(target=daily_report_worker, args=(application,), daemon=True)
    t.start()
    application.run_polling()

if __name__ == "__main__":
    init_db()
    flask_t = threading.Thread(target=run_flask, daemon=True)
    flask_t.start()
    run_telegram()